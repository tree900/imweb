<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>beipink universe Animation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #main-content { opacity: 0; transition: opacity 1s; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.137.0/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/math/MeshSurfaceSampler.js": "https://cdn.jsdelivr.net/npm/three@0.137.0/examples/jsm/math/MeshSurfaceSampler.js",
        "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.9.1/dist/gsap.min.js"
      }
    }
  </script>
</head>
<body>
  <div id="main-content">
    <!-- 메인 콘텐츠 -->
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
    import { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler.js';
    import gsap from 'gsap';

    let scene, camera, renderer;
    let textMesh, particles;
    const particleCount = 30000;
    const particlePositions = new Float32Array(particleCount * 3);

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const loader = new GLTFLoader();
      loader.load('path/to/beipink.glb', function(gltf) {
        textMesh = gltf.scene.children[0];
        applyGradientToText(textMesh);
        scene.add(textMesh);
        createParticles();
        animateText();
      });

      window.addEventListener('resize', onWindowResize, false);
      document.addEventListener('click', onMouseClick, false);
    }

    function applyGradientToText(mesh) {
      const material = new THREE.ShaderMaterial({
        uniforms: {
          color1: { value: new THREE.Color(0xffc0cb) },
          color2: { value: new THREE.Color(0xffffff) }
        },
        vertexShader: `
          varying vec3 vPosition;
          void main() {
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 color1;
          uniform vec3 color2;
          varying vec3 vPosition;
          void main() {
            float grad = (vPosition.y + 5.0) / 10.0;
            gl_FragColor = vec4(mix(color1, color2, grad), 1.0);
          }
        `,
        side: THREE.DoubleSide
      });
      mesh.material = material;
    }

    function createParticles() {
      const sampler = new MeshSurfaceSampler(textMesh).build();
      const particleGeometry = new THREE.BufferGeometry();
      for (let i = 0; i < particleCount; i++) {
        const position = new THREE.Vector3();
        sampler.sample(position);
        particlePositions.set([position.x, position.y, position.z], i * 3);
      }
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.5,
        color: 0xffc0cb
      });

      particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);
    }

    function animateText() {
      gsap.to(textMesh.rotation, {
        duration: 15,
        y: Math.PI * 2,
        ease: 'none',
        onComplete: () => {
          document.getElementById('main-content').style.opacity = 1;
        }
      });
    }

    function onMouseClick(event) {
      // 클릭한 위치의 입자들을 흩어지게 하는 로직 구현
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
